import socket
import threading
from loguru import logger
from xarxes2025.udpdatagram import UDPDatagram
from xarxes2025.videoprocessor import VideoProcessor
import time


class Server(object):
    def __init__(self, port):       
        """
        Initialize a new VideoStreaming server.

        :param port: The port to listen on.
        """
        self.video = None
        self.port = port
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.bind(("0.0.0.0", self.port))
        self.server_socket.listen(5)  # Allow 5 concurent client
        logger.info(f"Server RTSP created listening port {self.port}")
        self.start()
        
    def start(self):
        """Listens for incoming connections and creates a thread for each client"""
        while True:
            client_socket, client_address = self.server_socket.accept()
            logger.info(f"Online client from {client_address}")
            client_thread = threading.Thread(target=self.handle_client, args=(client_socket, client_address))
            client_thread.start()

    def handle_client(self, client_socket, client_address):
        """Manage communication with a client"""
        state = "INIT"  # Initialize state here
        session_id = "1234567890"  # can be autogenerated
        cseq = 0
        client_rtp_port = None
        client_ip = client_address[0]

        while True:
            try:
                # Read while find empty line, that will mark the end of RTSP message
                data = ""
                while True:
                    chunk = client_socket.recv(1024).decode()
                    data += chunk
                    if "\n\n" in data or "\r\n\r\n" in data:
                        break
                request = data.strip()
                if not request:
                    break

                logger.info(f"Recived from client:\n{request}")

                # Get order type (SETUP, PLAY, PAUSE, TEARDOWN)
                request_lines = request.split("\n")

                # Extract CSeq
                for line in request_lines:
                    if line.startswith("CSeq:"):
                        cseq = int(line.split(":")[1].strip())
                        break

                command = request_lines[0].split()[0]  # First word of the first line

                if command == "SETUP" and state == "INIT":
                    # Search header Transport to get client_port
                    transport_header = next((l for l in request_lines if l.startswith("Transport:")), None)
                    if transport_header:
                        parts = transport_header.split(";")
                        for part in parts:
                            if "client_port" in part:
                                client_rtp_port = int(part.split("=")[1])
                                logger.info(f"SETUP â†’ client IP: {client_ip}, RTP port: {client_rtp_port}")
                                break
                        if client_rtp_port is None:
                            response = f"RTSP/1.0 400 Bad Request\r\nCSeq: {cseq}\r\n\r\n"
                            client_socket.send(response.encode())
                            continue

                    # Switch to READY state and send response with transport confirmation
                    state = "READY"
                    logger.info(f"SETUP completed. IP={client_ip}, RTP port={client_rtp_port}")
                    response = (
                        f"RTSP/1.0 200 OK\r\n"
                        f"CSeq: {cseq}\r\n"
                        f"Session: {session_id}\r\n"
                        f"Transport: RTP/UDP; client_port={client_rtp_port}\r\n"
                        f"\r\n"
                    )
                    client_socket.send(response.encode())
                    continue

                elif command == "PLAY" and state == "READY":
                    state = "PLAYING"
                    response = (
                        f"RTSP/1.0 200 OK\r\n"
                        f"CSeq: {cseq}\r\n"
                        f"Session: {session_id}\r\n"
                        f"\r\n"
                    )
                    client_socket.send(response.encode())

                    # Send video as a thread
                    threading.Thread(
                        target=self.send_udp_frame,
                        args=(client_ip, client_rtp_port),
                        daemon=True
                    ).start()
                    continue

                elif command == "PAUSE" and state == "PLAYING":
                    state = "READY"
                    response = (
                        f"RTSP/1.0 200 OK\r\n"
                        f"CSeq: {cseq}\r\n"
                        f"Session: {session_id}\r\n"
                        f"\r\n"
                    )
                    client_socket.send(response.encode())
                    continue

                elif command == "TEARDOWN":
                    state = "INIT"
                    response = (
                        f"RTSP/1.0 200 OK\r\n"
                        f"CSeq: {cseq}\r\n"
                        f"Session: {session_id}\r\n"
                        f"\r\n"
                    )
                    client_socket.send(response.encode())
                    break  # End connection

                else:
                    response = "RTSP/1.0 400 Bad Request\n\n"

                client_socket.send(response.encode())

            except Exception as e:
                logger.error(f"Error with client: {e}")
                break

        client_socket.close()
        logger.info("Offline client")

    def send_udp_frame(self, client_ip, client_rtp_port):
        # This snippet reads from self.video (a VideoProcessor object) and prepares
        # the frame to be sent over UDP.

        logger.info(f"Strarting sending video to {client_ip}:{client_rtp_port}")

        # create UDP socket
        socketudp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        # create video processor
        self.video = VideoProcessor("rick.webp")

        while True:
            data = self.video.next_frame()
            if not data:
                logger.info("End of video stream")
                break

            frame_number = self.video.get_frame_number()
            udp_datagram = UDPDatagram(frame_number, data).get_datagram()
            socketudp.sendto(udp_datagram, (client_ip, client_rtp_port))
            logger.debug(f"Frame {frame_number} sent")

            time.sleep(0.25)

        socketudp.close()